<template>
  <div class="chat-container">
    <!-- Fester Haupttitel -->
    <div class="fixed-header">
      <h1 class="text-xl font-bold text-center py-3 text-gray-800 dark:text-white shadow-sm">Ideation Chat</h1>
    </div>

    <!-- Mobile Sidebar Toggle -->
    <button 
      v-if="isMobile" 
      @click="toggleMobileMenu" 
      class="fixed bottom-4 left-4 z-30 bg-blue-600 text-white p-3 rounded-full shadow-xl hover:bg-blue-700 transition-all"
    >
      <svg v-if="!mobileMenuOpen" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
      </svg>
      <svg v-else class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>

    <!-- Linke Sidebar - sichtbar auf Desktop oder wenn aktiviert auf Mobile -->
    <div 
      :class="{
        'w-80': (!isMobile || mobileMenuOpen) && !sidebarCollapsed, 
        'w-0': isMobile && !mobileMenuOpen,
        'w-16': !isMobile && sidebarCollapsed
      }" 
      class="bg-white dark:bg-gray-800 h-full border-r border-gray-200 dark:border-gray-700 flex flex-col overflow-hidden transition-all duration-300 group sidebar-container shadow-sm"
      @mouseenter="!isMobile && (sidebarCollapsed = false)"
      @mouseleave="!isMobile && (sidebarCollapsed = true)"
    >
      <!-- Neuer Chat Button -->
      <div class="p-4">
        <router-link 
          :to="{ name: 'idea-chat' }" 
          custom
          v-slot="{ navigate }"
        >
          <button 
            @click="navigate"
            class="w-full flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white py-3 px-4 rounded-lg shadow-md transition-all hover:shadow-lg"
          >
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
            <span v-if="!sidebarCollapsed || mobileMenuOpen">New Chat</span>
          </button>
        </router-link>
                  </div>
      
      <!-- Chat-Verlauf -->
      <div 
        class="flex-1 overflow-auto px-3 py-2"
        :class="{'hidden': sidebarCollapsed && !isMobile, 'block': !sidebarCollapsed || isMobile}"
      >
        <!-- Heutige Chats -->
        <div v-if="todayChats.length > 0" class="mb-6">
          <h3 class="text-xs font-medium text-gray-500 mb-2 px-3">TODAY</h3>
          <div class="space-y-1">
            <div 
              v-for="chat in todayChats" 
              :key="chat.id"
              class="flex items-center justify-between px-3 py-2 rounded-md cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 w-full sidebar-chat-item"
              :class="{'bg-gray-100 dark:bg-gray-700 font-medium': isChatActive(chat)}"
            >
              <p 
                @click="loadChat(chat)" 
                class="text-sm text-gray-800 dark:text-gray-200 truncate max-w-[calc(100%-30px)] overflow-hidden text-ellipsis whitespace-nowrap"
              >
                {{ chat.title || 'Untitled Chat' }}
              </p>
              <div @click.stop="confirmDeleteChat(chat)" class="trash-icon ml-1 w-5 h-5 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                  <path fill-rule="evenodd" d="M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z" clip-rule="evenodd" />
                </svg>
                </div>
                  </div>
                </div>
              </div>
              
        <!-- Chats der letzten Woche -->
        <div v-if="lastWeekChats.length > 0" class="mb-6">
          <h3 class="text-xs font-medium text-gray-500 mb-2 px-3">LAST WEEK</h3>
          <div class="space-y-1">
            <div 
              v-for="chat in lastWeekChats" 
              :key="chat.id"
              class="flex items-center justify-between px-3 py-2 rounded-md cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 w-full sidebar-chat-item"
              :class="{'bg-gray-100 dark:bg-gray-700 font-medium': isChatActive(chat)}"
            >
              <p 
                @click="loadChat(chat)" 
                class="text-sm text-gray-800 dark:text-gray-200 truncate max-w-[calc(100%-30px)] overflow-hidden text-ellipsis whitespace-nowrap"
              >
                {{ chat.title || 'Untitled Chat' }}
              </p>
              <div @click.stop="confirmDeleteChat(chat)" class="trash-icon ml-1 w-5 h-5 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                  <path fill-rule="evenodd" d="M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z" clip-rule="evenodd" />
                </svg>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Ältere Chats -->
        <div v-if="olderChats.length > 0" class="mb-6">
          <h3 class="text-xs font-medium text-gray-500 mb-2 px-3">OLDER</h3>
          <div class="space-y-1">
            <div 
              v-for="chat in olderChats" 
              :key="chat.id"
              class="flex items-center justify-between px-3 py-2 rounded-md cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 w-full sidebar-chat-item"
              :class="{'bg-gray-100 dark:bg-gray-700 font-medium': isChatActive(chat)}"
            >
              <p 
                @click="loadChat(chat)" 
                class="text-sm text-gray-800 dark:text-gray-200 truncate max-w-[calc(100%-30px)] overflow-hidden text-ellipsis whitespace-nowrap"
              >
                {{ chat.title || 'Untitled Chat' }}
              </p>
              <div @click.stop="confirmDeleteChat(chat)" class="trash-icon ml-1 w-5 h-5 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                  <path fill-rule="evenodd" d="M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z" clip-rule="evenodd" />
                </svg>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Hilfebuttton unten -->
      <div class="p-4 border-t border-gray-200 dark:border-gray-700">
        <!-- Question mark button removed -->
      </div>
    </div>
    
    <!-- Chat-Hauptbereich -->
    <div class="chat-main">
      <!-- Chat Header mit Titel und Aktionen - NUR anzeigen, wenn eine Nachricht existiert -->
      <div v-if="messages.length > 0" class="chat-header">
        <div class="flex items-center justify-between max-w-4xl mx-auto">
          <div class="flex items-center">
            <h2 class="text-lg font-medium text-gray-900 dark:text-white">{{ chatTitle || 'New Chat' }}</h2>
            <button @click="editChatTitle" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 ml-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
              </svg>
                </button>
          </div>
          <div class="flex space-x-2">
            <!-- Header buttons -->
          </div>
        </div>
      </div>
      
      <!-- Chat Messages Area - ONLY THIS SHOULD SCROLL -->
      <div class="chat-messages">
        <!-- Willkommensbildschirm, wenn keine Nachrichten vorhanden -->
        <div v-if="messages.length === 0" class="flex flex-col items-center justify-start h-full pt-4">
          <h2 class="text-xl font-bold mb-2 text-gray-900 dark:text-white">Welcome to Ideation Chat</h2>
          <p class="text-gray-600 dark:text-gray-400 mb-4 max-w-md text-center">Your partner for banger YouTube video ideas</p>
          
          <div class="text-left w-full max-w-2xl mb-3">
            <h3 class="font-medium mb-2">Try These Examples</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
              <div class="bg-white p-3 rounded-lg shadow cursor-pointer hover:bg-gray-50" @click="useExample('Analyze @MrBeast\'s content strategy')">
                <div class="flex items-center">
                  <span class="text-red-500 mr-2">🔍</span>
                  <div>
                    <p class="font-medium text-sm">Analyze @MrBeast's strategy</p>
                    <p class="text-xs text-gray-600">Get insights into successful content</p>
                  </div>
                </div>
              </div>
              <div class="bg-white p-3 rounded-lg shadow cursor-pointer hover:bg-gray-50" @click="useExample('Generate engaging titles')">
                <div class="flex items-center">
                  <span class="text-red-500 mr-2">✨</span>
                  <div>
                    <p class="font-medium text-sm">Generate engaging titles</p>
                    <p class="text-xs text-gray-600">Create catchy video titles</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <button @click="openPromptLibrary" class="flex items-center bg-white px-3 py-2 rounded-lg shadow">
            <span class="mr-2">📚</span> Browse Prompt Library
                </button>
          
          <div class="mt-4 text-gray-500 flex space-x-6 text-sm">
            <p>@username to analyze channels</p>
            <p>paste video URL for analysis</p>
              </div>
              
          <!-- Anleitung zum Hinzufügen von Channels für den Kontext -->
          <div class="mt-4 p-3 bg-blue-50 text-blue-800 rounded-lg max-w-2xl">
            <div class="flex items-start">
              <div class="flex-shrink-0">
                <svg class="h-4 w-4 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </div>
              <div class="ml-2">
                <h3 class="text-xs font-medium">Tip: Add channels for context</h3>
                <p class="mt-1 text-xs">
                  Add your YouTube channels in the Dashboard first for better results.
                </p>
                <div class="mt-1">
                  <router-link :to="{ name: 'add-channel' }" class="text-xs font-medium text-blue-600 hover:text-blue-500">
                    Add a channel <span aria-hidden="true">&rarr;</span>
                  </router-link>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Chatverlauf -->
        <div v-else class="max-w-3xl mx-auto">
          <div 
            v-for="(message, index) in formattedMessages" 
            :key="index"
            class="mb-4"
          >
            <!-- User Message Bubble -->
            <div v-if="message.isUser" class="flex justify-end mb-8">
              <div class="bg-blue-600 text-white p-5 rounded-2xl shadow-md max-w-md">
                <p class="whitespace-pre-wrap break-words text-base">{{ message.content }}</p>
              </div>
              <div class="w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center ml-3 self-start shadow-md">
                <span>J</span>
              </div>
            </div>
            
            <!-- AI Message Bubble -->
            <div v-else class="flex mb-8">
              <div class="w-10 h-10 rounded-full bg-white dark:bg-gray-700 text-gray-800 dark:text-white flex items-center justify-center mr-3 self-start shadow-md border border-gray-200 dark:border-gray-600">
                <span>YT</span>
              </div>
              <div class="relative bg-white dark:bg-gray-800 p-5 rounded-2xl shadow-md max-w-2xl border border-gray-100 dark:border-gray-700">
                <!-- Context Menu Button -->
                <div class="absolute right-0 top-0 -mr-6 mt-1 flex flex-col items-center space-y-1">
                  <!-- Channel Link -->
                  <button @click="openChannelLink(message)" class="p-1 text-gray-500 hover:text-blue-600 bg-white dark:bg-gray-700 rounded-full shadow-sm w-7 h-7 flex items-center justify-center transition-all hover:shadow-md">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                  </button>
                  
                  <!-- Script Link -->
                  <button @click="openScriptLink(message)" class="p-1 text-gray-500 hover:text-blue-600 bg-white dark:bg-gray-700 rounded-full shadow-sm w-7 h-7 flex items-center justify-center transition-all hover:shadow-md">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                  </button>
                  
                  <!-- Prompt Library Button -->
                  <button @click="openPromptLibrary" class="p-1 text-gray-500 hover:text-blue-600 bg-white dark:bg-gray-700 rounded-full shadow-sm w-7 h-7 flex items-center justify-center transition-all hover:shadow-md">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                    </svg>
                  </button>
                </div>
                
                <!-- Loading state -->
                <div v-if="message.isLoading" class="flex flex-col">
                  <div class="flex space-x-2">
                    <div class="w-3 h-3 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce"></div>
                    <div class="w-3 h-3 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                    <div class="w-3 h-3 bg-gray-300 dark:bg-gray-600 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                  </div>
                  <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">{{ message.content }}</p>
                </div>
                <!-- Rendered message -->
                <div v-else class="prose dark:prose-invert prose-sm max-w-none text-gray-800 dark:text-gray-200 text-base" v-html="message.formattedContent"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Input area - Fixed at bottom -->
      <div class="chat-input">
        <div class="max-w-3xl mx-auto">
          <!-- Kontext-Anzeige, wenn vorhanden -->
          <div v-if="activeContext" class="mb-2 px-4 py-1 bg-indigo-50 dark:bg-indigo-900/20 rounded-md flex items-center justify-between">
            <div class="flex items-center text-sm text-indigo-700 dark:text-indigo-300">
              <span v-if="activeContext.type === 'channel'" class="mr-2">📺</span>
              <span v-else-if="activeContext.type === 'script'" class="mr-2">📝</span>
              <span>{{ activeContext.name }}</span>
            </div>
            <button @click="clearContext" class="text-indigo-500 hover:text-indigo-700 dark:text-indigo-300 dark:hover:text-indigo-100">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <!-- Texteingabe mit Buttons -->
          <div class="flex items-center space-x-2 bg-white dark:bg-gray-800 rounded-xl shadow-md border border-gray-200 dark:border-gray-700 overflow-hidden mx-4 mb-4">
            <!-- Button to add context -->
            <button 
              @click="showContextDropdown = !showContextDropdown" 
              class="text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400 p-4 bg-gray-50 dark:bg-gray-700 context-button transition-colors"
            >
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
              </svg>
            </button>
            
            <div class="relative flex-1">
                  <textarea 
                    v-model="newMessage" 
                rows="1"
                placeholder="Ask anything about YouTube..." 
                class="w-full px-4 py-4 bg-white dark:bg-gray-800 border-0 focus:ring-0 resize-none text-base"
                :class="{'h-12': newMessage.length < 100, 'h-24': newMessage.length >= 100}"
                @keydown.enter.ctrl="sendMessage"
                @keydown="e => e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), sendMessage())"
                  ></textarea>
              
              <!-- Hints -->
              <div class="absolute right-3 bottom-2 flex items-center gap-2 text-gray-400 text-xs">
                <span>Use shift + enter for new line</span>
                </div>
            </div>
            
            <!-- Send Button -->
                  <button 
              @click="sendMessage" 
                    :disabled="isLoading || !newMessage.trim()"
              class="bg-blue-600 hover:bg-blue-700 text-white p-4 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              <svg v-if="!isLoading" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
              </svg>
              <svg v-else class="w-5 h-5 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
                  </button>
                </div>
          
          <!-- Message counter if applicable -->
          <div class="mt-1 text-center text-xs text-gray-500">
            15 messages remaining on trial. <a href="#" class="text-indigo-600 hover:underline">Upgrade for continued access</a>
            </div>
          </div>
        </div>
      </div>
    
    <!-- Prompt-Bibliothek Modal -->
    <div v-if="showPromptLibrary" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white rounded-xl w-full max-w-5xl h-3/4 overflow-hidden flex flex-col shadow-2xl">
        <div class="flex justify-between items-center p-5 border-b border-gray-200 dark:border-gray-700">
          <h2 class="text-xl font-bold text-gray-900 dark:text-white">Prompt Library</h2>
          <button @click="showPromptLibrary = false" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        <div class="flex flex-1 overflow-hidden">
          <!-- Categories Sidebar -->
          <div class="w-64 bg-gray-50 dark:bg-gray-700 overflow-y-auto p-3 border-r border-gray-200 dark:border-gray-600">
            <div 
              v-for="category in promptCategories" 
              :key="category.name"
              @click="selectPromptCategory(category)"
              :class="{'bg-blue-50 text-blue-700 dark:bg-blue-900/20 dark:text-blue-300': selectedCategory === category}"
              class="p-3 hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer rounded-lg mb-2 flex items-center transition-colors"
            >
              <span class="mr-2 text-xl">
                <template v-if="category.name === 'YouTube Ideas'">🚀</template>
                <template v-else-if="category.name === 'Content Strategy'">📊</template>
                <template v-else-if="category.name === 'Video Production'">🎬</template>
                <template v-else>📝</template>
              </span>
              <span class="font-medium">{{ category.name }}</span>
            </div>
          </div>
          
          <!-- Prompts -->
          <div class="flex-1 overflow-y-auto p-5 bg-white dark:bg-gray-800">
            <div v-if="selectedCategory">
              <h3 class="text-xl font-semibold mb-5 text-gray-900 dark:text-white">{{ selectedCategory.name }} Prompts</h3>
              
              <div 
                v-for="prompt in selectedCategory.prompts" 
                :key="prompt.title"
                class="mb-6 border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden shadow-sm hover:shadow-md transition-shadow"
              >
                <div class="flex items-center p-4 border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-700">
                  <span class="mr-3 text-blue-500 text-xl">📝</span>
                  <span class="font-medium text-gray-900 dark:text-white text-lg">{{ prompt.title }}</span>
                </div>
                <div class="p-5 bg-white dark:bg-gray-800">
                  <p class="text-gray-700 dark:text-gray-300 whitespace-pre-wrap">{{ prompt.content }}</p>
                </div>
                <div class="border-t border-gray-200 dark:border-gray-700 p-4 bg-gray-50 dark:bg-gray-700 text-right">
                  <button 
                    @click="usePrompt(prompt)" 
                    class="bg-blue-600 text-white px-5 py-2 rounded-lg text-sm hover:bg-blue-700 shadow-sm hover:shadow-md transition-all"
                  >
                    Use Prompt
                  </button>
                </div>
              </div>
            </div>
            
            <div v-else class="flex flex-col items-center justify-center h-full">
              <div class="text-center p-8">
                <div class="text-5xl mb-4">📚</div>
                <h3 class="text-xl font-semibold mb-2 text-gray-900 dark:text-white">Select a Category</h3>
                <p class="text-gray-600 dark:text-gray-400">Choose a prompt category from the sidebar to view available prompts.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Chat Title Edit Modal -->
    <div v-if="showTitleEdit" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white dark:bg-gray-800 rounded-xl w-full max-w-md overflow-hidden shadow-2xl">
        <div class="p-5 border-b border-gray-200 dark:border-gray-700">
          <h2 class="text-xl font-bold text-gray-900 dark:text-white">Edit Chat Title</h2>
        </div>
        <div class="p-5">
          <input 
            v-model="editedTitle" 
            type="text" 
            class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-900 dark:text-white text-base"
            placeholder="Enter a title for this chat"
          >
        </div>
        <div class="flex justify-end p-4 border-t border-gray-200 dark:border-gray-700">
          <button @click="showTitleEdit = false" class="text-gray-600 dark:text-gray-400 px-4 py-2 mr-2">Cancel</button>
          <button @click="saveChatTitle" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">Save</button>
        </div>
      </div>
    </div>
    
    <!-- Chat-Historie Modal -->
    <div v-if="showChatHistory" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white rounded-lg w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
        <div class="flex justify-between items-center p-4 border-b">
          <h2 class="text-lg font-bold">Chat History</h2>
          <button @click="showChatHistory = false" class="text-gray-500 hover:text-gray-700">×</button>
        </div>
        
        <div class="flex-1 overflow-y-auto p-4">
          <div v-if="chatHistory.length === 0" class="text-center text-gray-500 py-8">
            No saved chats found.
          </div>
          <div v-else class="space-y-3">
            <div 
              v-for="(chat, index) in chatHistory" 
              :key="index"
              class="p-3 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100"
              @click="loadChat(chat)"
            >
              <div class="font-medium">{{ chat.title || 'Untitled Chat' }}</div>
              <div class="text-sm text-gray-500">{{ formatDate(chat.date) }}</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Kontext-Dropdown -->
    <div 
      v-if="showContextDropdown" 
      class="fixed right-0 bottom-20 w-80 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 z-20 overflow-hidden context-dropdown"
    >
      <!-- Tab Navigation -->
      <div class="flex border-b border-gray-200 dark:border-gray-700">
        <button 
          @click="activeTab = 'channels'" 
          class="flex-1 py-2 px-4 text-sm font-medium"
          :class="{
            'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white': activeTab === 'channels',
            'text-gray-600 dark:text-gray-400': activeTab !== 'channels'
          }"
        >
          YouTube Channels
        </button>
        <button 
          @click="activeTab = 'scripts'" 
          class="flex-1 py-2 px-4 text-sm font-medium"
          :class="{
            'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white': activeTab === 'scripts',
            'text-gray-600 dark:text-gray-400': activeTab !== 'scripts'
          }"
        >
          Video Scripts
        </button>
      </div>
      
      <!-- Search & Content -->
      <div class="p-4">
        <input 
          type="text" 
          v-model="contextSearch"
          :placeholder="activeTab === 'channels' ? 'Search channels...' : 'Search scripts...'" 
          class="w-full p-2 mb-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md text-gray-800 dark:text-gray-200 placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500"
        >
        
        <!-- Channels Tab -->
        <div v-if="activeTab === 'channels'" class="max-h-48 overflow-y-auto">
          <div v-if="filteredChannels.length === 0" class="text-center p-4 text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-700/50 rounded-md">
            No channels found
            <div class="mt-2">
              <router-link to="/channels/new" class="text-indigo-600 dark:text-indigo-400 hover:underline text-sm">
                + Add a new channel
              </router-link>
            </div>
          </div>
          
          <div 
            v-for="channel in filteredChannels" 
            :key="channel.id" 
            @click="selectContext('channel', channel.id, channel.name)"
            class="p-3 mb-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border border-gray-200 dark:border-gray-700"
          >
            <div class="flex items-center">
              <div class="flex-shrink-0 bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 p-2 rounded-full">
                <span>📺</span>
              </div>
              <div class="ml-3">
                <div class="font-medium">{{ channel.name }}</div>
                <div class="text-xs text-gray-500 dark:text-gray-400 truncate">{{ channel.description || 'No description' }}</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Scripts Tab -->
        <div v-if="activeTab === 'scripts'" class="max-h-48 overflow-y-auto">
          <div v-if="filteredScripts.length === 0" class="text-center p-4 text-gray-500 dark:text-gray-400 bg-gray-50 dark:bg-gray-700/50 rounded-md">
            No scripts found
            <div class="mt-2">
              <router-link to="/scripts/new" class="text-indigo-600 dark:text-indigo-400 hover:underline text-sm">
                + Create a new script
              </router-link>
            </div>
          </div>
          
          <div 
            v-for="script in filteredScripts" 
            :key="script.id" 
            @click="selectContext('script', script.id, script.name)"
            class="p-3 mb-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border border-gray-200 dark:border-gray-700"
          >
            <div class="flex items-center">
              <div class="flex-shrink-0 bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 p-2 rounded-full">
                <span>📝</span>
              </div>
              <div class="ml-3">
                <div class="font-medium">{{ script.name }}</div>
                <div class="text-xs text-gray-500 dark:text-gray-400 truncate">
                  {{ script.description || (script.content ? script.content.substring(0, 50) + '...' : 'No content') }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Bestätigungs-Modal für Chat-Löschung -->
    <div v-if="showDeleteConfirm" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white dark:bg-gray-800 rounded-lg w-full max-w-md overflow-hidden shadow-xl">
        <div class="p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 class="text-lg font-bold text-gray-900 dark:text-white">Delete Chat</h2>
        </div>
        <div class="p-4">
          <p class="text-gray-700 dark:text-gray-300">Are you sure you want to delete this chat? This action cannot be undone.</p>
          <p class="mt-2 text-sm text-gray-600 dark:text-gray-400 font-medium">{{ chatToDelete?.title || 'Untitled Chat' }}</p>
        </div>
        <div class="flex justify-end p-4 border-t border-gray-200 dark:border-gray-700">
          <button @click="cancelDeleteChat" class="text-gray-600 dark:text-gray-400 px-4 py-2 mr-2">Cancel</button>
          <button @click="confirmAndDeleteChat" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">Delete</button>
        </div>
      </div>
    </div>

    <!-- Supabase Status Debug -->
    <div class="supabase-status-debug fixed top-20 right-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg z-50 max-w-md">
      <h3 class="font-bold mb-2">Supabase Cloud-Sync Status</h3>
      <div class="text-sm space-y-1">
        <p><span class="font-medium">Verbindung:</span> 
          <span :class="supabaseStatus.connected ? 'text-green-600' : 'text-red-600'">
            {{ supabaseStatus.connected ? 'Erfolgreich' : 'Nicht verbunden' }}
          </span>
        </p>
        <p><span class="font-medium">Tabelle existiert:</span> 
          <span :class="supabaseStatus.tableExists ? 'text-green-600' : 'text-red-600'">
            {{ supabaseStatus.tableExists ? 'Ja' : 'Nein' }}
          </span>
        </p>
        <p><span class="font-medium">Eingeloggt:</span> 
          <span :class="supabaseStatus.loggedIn ? 'text-green-600' : 'text-red-600'">
            {{ supabaseStatus.loggedIn ? 'Ja' : 'Nein' }}
          </span>
        </p>
        <p v-if="supabaseStatus.email"><span class="font-medium">E-Mail:</span> {{ supabaseStatus.email }}</p>
        <p v-if="supabaseStatus.userId"><span class="font-medium">User ID:</span> {{ supabaseStatus.userId.slice(0, 8) }}...</p>
        <p v-if="supabaseStatus.error" class="text-red-600"><span class="font-medium">Fehler:</span> {{ supabaseStatus.error }}</p>
        <p><span class="font-medium">Status:</span> {{ supabaseStatus.message }}</p>
        <p v-if="supabaseStatus.lastSync"><span class="font-medium">Letzte Synchronisation:</span> {{ formatTime(supabaseStatus.lastSync) }}</p>
        <p v-if="supabaseStatus.lastSyncResult" :class="{'text-green-600': supabaseStatus.lastSyncResult === 'Erfolgreich', 'text-red-600': supabaseStatus.lastSyncResult !== 'Erfolgreich'}">
          <span class="font-medium">Ergebnis:</span> {{ supabaseStatus.lastSyncResult }}
        </p>
        
        <div class="mt-4 flex space-x-2 flex-wrap">
          <button 
            @click="forceSyncWithSupabase" 
            :disabled="supabaseStatus.syncInProgress"
            class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 disabled:opacity-50 mb-2"
          >
            {{ supabaseStatus.syncInProgress ? 'Synchronisiere...' : 'Jetzt synchronisieren' }}
          </button>
          
          <button 
            @click="createSupabaseTable" 
            :disabled="supabaseStatus.tableExists"
            class="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700 disabled:opacity-50 mb-2"
          >
            Tabelle erstellen
          </button>
          
          <button 
            @click="testSaveChat"
            class="bg-orange-600 text-white px-3 py-1 rounded text-sm hover:bg-orange-700 mb-2"
          >
            Test-Chat speichern
          </button>
          
          <button 
            @click="checkChatTable"
            class="bg-purple-600 text-white px-3 py-1 rounded text-sm hover:bg-purple-700 mb-2"
          >
            Tabelle prüfen
          </button>
          
          <button 
            @click="dumpSupabaseState"
            class="bg-gray-600 text-white px-3 py-1 rounded text-sm hover:bg-gray-700 mb-2"
          >
            Status Dump
          </button>
        </div>
        
        <div v-if="debugInfo" class="mt-3 p-2 bg-gray-100 dark:bg-gray-700 rounded-md text-xs overflow-auto max-h-60">
          <pre>{{ debugInfo }}</pre>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { supabase } from '../supabase';
import { marked } from 'marked'; // Markdown Parser
import DOMPurify from 'dompurify'; // Für sicheres HTML
import emojione from 'emojione'; // Emoji-Parser

export default {
  name: 'IdeaChat',
  data() {
    return {
      messages: [],
      newMessage: '',
      isLoading: false,
      selectedAI: 'gpt',
      showModelSelector: false,
      showContextDropdown: false,
      activeTab: 'channels',
      contextSearch: '',
      activeContext: null,
      channels: [],
      scripts: [],
      showPromptLibrary: false,
      promptCategories: [
        {
          name: 'YouTube Ideas',
          prompts: [
            { title: 'Viral Video Concept', content: 'Generate a viral video concept for YouTube that would appeal to [target audience] and is based on current trends.' },
            { title: 'Video Script Template', content: 'Create a script template for a [duration] minute YouTube video about [topic] that includes hooks, segments, and call-to-actions.' },
            { title: 'Trending Topic Analysis', content: 'Analyze the current trending topics on YouTube in the [niche] niche and suggest 5 video ideas that could capitalize on these trends.' }
          ]
        },
        {
          name: 'Content Strategy',
          prompts: [
            { title: 'Channel Optimization', content: 'Provide recommendations to optimize my YouTube channel about [topic] to increase subscribers and engagement.' },
            { title: 'Content Calendar', content: 'Create a one-month content calendar for my YouTube channel about [topic] with video ideas, optimal posting times, and strategic themes.' },
            { title: 'Audience Growth Strategy', content: 'Develop an audience growth strategy for my YouTube channel focusing on [niche] with specific tactics to increase subscribers.' }
          ]
        },
        {
          name: 'Video Production',
          prompts: [
            { title: 'B-Roll Ideas', content: 'Suggest creative B-roll ideas for a YouTube video about [topic] that would enhance the visual storytelling.' },
            { title: 'Editing Tips', content: 'Provide advanced editing tips and techniques that would make my YouTube videos about [topic] more engaging and professional.' },
            { title: 'Thumbnail Design', content: 'Design concepts for eye-catching thumbnails for a YouTube video about [topic] that would increase click-through rates.' }
          ]
        }
      ],
      selectedCategory: null,
      showTitleEdit: false,
      editedTitle: '',
      showChatHistory: false,
      chatHistory: [],
      currentChatId: null,
      // Neue Features
      isMobile: false,
      isTypingEffect: false,
      typingText: '',
      typingIndex: 0,
      typing: null,
      autoScrollEnabled: true,
      mobileMenuOpen: false,
      themePreference: localStorage.getItem('theme') || 'light',
      sidebarCollapsed: true,
      showDeleteConfirm: false,
      chatToDelete: null,
      // Supabase Debug Info
      supabaseStatus: {
        connected: false,
        tableExists: false,
        loggedIn: false,
        error: null,
        message: 'Überprüfe Supabase-Verbindung...',
        userId: null,
        email: null,
        lastSync: null,
        lastSyncResult: null,
        syncInProgress: false
      },
      debugInfo: null,
      showDebugPanel: false,
    };
  },
  computed: {
    filteredChannels() {
      if (!this.contextSearch) return this.channels;
      const searchLower = this.contextSearch.toLowerCase();
      return this.channels.filter(channel => 
        channel.name.toLowerCase().includes(searchLower)
      );
    },
    filteredScripts() {
      if (!this.contextSearch) return this.scripts;
      const searchLower = this.contextSearch.toLowerCase();
      return this.scripts.filter(script => 
        script.name.toLowerCase().includes(searchLower)
      );
    },
    todayChats() {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      return this.chatHistory.filter(chat => {
        const chatDate = new Date(chat.date);
        return chatDate >= today;
      });
    },
    lastWeekChats() {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const lastWeekStart = new Date(today);
      lastWeekStart.setDate(today.getDate() - 7);
      
      return this.chatHistory.filter(chat => {
        const chatDate = new Date(chat.date);
        return chatDate >= lastWeekStart && chatDate < today;
      });
    },
    olderChats() {
      const lastWeekStart = new Date();
      lastWeekStart.setHours(0, 0, 0, 0);
      lastWeekStart.setDate(lastWeekStart.getDate() - 7);
      
      return this.chatHistory.filter(chat => {
        const chatDate = new Date(chat.date);
        return chatDate < lastWeekStart;
      });
    },
    // Formatierte Nachrichten mit Markdown und Emojis
    formattedMessages() {
      return this.messages.map(message => {
        if (!message.isUser) {
          // Markdown und Emojis für AI-Antworten
          return {
            ...message,
            formattedContent: this.formatMessageContent(message.content)
          };
        }
        return message;
      });
    }
  },
  watch: {
    // Auto-Scrollen, wenn neue Nachrichten hinzugefügt werden
    messages: {
      deep: true,
      handler() {
        if (this.autoScrollEnabled) {
          this.$nextTick(() => {
            this.scrollToBottom();
          });
        }
      }
    },
    // Darkmode/Light Mode Wechsel
    themePreference: {
      handler(newValue) {
        document.documentElement.classList.toggle('dark', newValue === 'dark');
        localStorage.setItem('theme', newValue);
      },
      immediate: true
    },
    // Watch for route changes
    '$route': {
      handler(to, from) {
        if (to.name === 'idea-chat' && !to.params.chatId) {
          // When navigating to the base route, clear the current chat
          this.clearCurrentChat();
        } else if (to.name === 'specific-chat' && to.params.chatId) {
          // When navigating to a specific chat, load it if it's different from current
          if (this.currentChatId !== to.params.chatId) {
            this.loadChatById(to.params.chatId);
          }
        }
      },
      immediate: true
    }
  },
  async created() {
    // Test Supabase connection first
    await this.checkSupabaseConnection();
    
    // Then fetch channels and scripts
    await this.fetchChannelsAndScripts();
    await this.fetchPromptLibrary();
    
    // Load chat history after connection is tested
    await this.loadChatHistory();
    
    // Handle the initial route
    if (this.$route.name === 'specific-chat' && this.$route.params.chatId) {
      // Try to load the specific chat
      const loaded = await this.loadChatById(this.$route.params.chatId);
      if (!loaded) {
        // If chat not found, redirect to the base chat route
        this.$router.push({ name: 'idea-chat' });
      }
    } else if (this.$route.name === 'idea-chat') {
      // Clear any existing chat when on the base route
      this.clearCurrentChat();
    }
    
    this.detectMobile();
    window.addEventListener('resize', this.detectMobile);
    
    // Add event listener to close dropdowns when clicking outside
    document.addEventListener('click', this.handleOutsideClick);
  },

  // Einfache Funktion zur Überprüfung der Supabase-Verbindung
  async checkSupabaseConnection() {
    try {
      console.log("Prüfe Supabase-Verbindung...");
      // Einfacher Verbindungstest
      const { data, error } = await supabase.from('idea_chats').select('count').limit(1);
      
      if (error) {
        console.error("Supabase Verbindungsproblem:", error);
      } else {
        console.log("Supabase-Verbindung erfolgreich");
      }
    } catch (error) {
      console.error("Fehler bei Supabase-Verbindungsprüfung:", error);
    }
  },
  mounted() {
    // Initial scroll
    this.scrollToBottom();
    
    // Event-Listener für Tastenkombinationen
    document.addEventListener('keydown', this.handleKeyboardShortcuts);
    
    // Detect navbar height and set CSS variable
    this.setNavbarHeight();
    window.addEventListener('resize', this.setNavbarHeight);
  },
  beforeDestroy() {
    window.removeEventListener('resize', this.detectMobile);
    document.removeEventListener('keydown', this.handleKeyboardShortcuts);
    document.removeEventListener('click', this.handleOutsideClick);
    window.removeEventListener('resize', this.setNavbarHeight);
  },
  methods: {
    async fetchChannelsAndScripts() {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) return;
        
        // Initialisiere leere Arrays für den Fall, dass die Tabellen nicht existieren
        this.channels = [];
        this.scripts = [];
        
        try {
          // Versuche channels zu laden
          const { data: channels, error: channelsError } = await supabase
            .from('channels')
            .select('id, title')
            .eq('user_id', session.user.id);
            
          if (channelsError) {
            // Prüfe, ob es sich um einen "Tabelle existiert nicht" Fehler handelt
            if (channelsError.code === '42P01') {
              console.warn('Channels table does not exist. Will be created when you add your first channel.');
            } else {
              console.error('Error fetching channels:', channelsError);
            }
          } else if (channels) {
            this.channels = channels.map(c => ({
              id: c.id,
              name: c.title
            }));
          }
        } catch (error) {
          console.error('Error with channels request:', error);
        }

        try {
          // Versuche scripts zu laden
          const { data: scripts, error: scriptsError } = await supabase
            .from('scripts')
            .select('id, title')
            .eq('user_id', session.user.id);
            
          if (scriptsError) {
            // Prüfe, ob es sich um einen "Tabelle existiert nicht" Fehler handelt
            if (scriptsError.code === '42P01') {
              console.warn('Scripts table does not exist. Will be created when you add your first script.');
            } else {
              console.error('Error fetching scripts:', scriptsError);
            }
          } else if (scripts) {
            this.scripts = scripts.map(s => ({
              id: s.id,
              name: s.title
            }));
          }
        } catch (error) {
          console.error('Error with scripts request:', error);
        }
      } catch (error) {
        console.error('Error in fetchChannelsAndScripts:', error);
      }
    },
    async fetchPromptLibrary() {
      try {
        const response = await axios.get('/chat/prompt-library');
        this.promptLibrary = response.data;
        
        if (this.promptLibrary.length > 0) {
          this.activeCategory = this.promptLibrary[0].category;
        }
      } catch (error) {
        console.error('Error fetching prompt library:', error);
      }
    },
    async sendMessage() {
      if (!this.newMessage.trim() || this.isLoading) return;

      const userMessage = {
        content: this.newMessage,
        isUser: true
      };

      this.messages.push(userMessage);
      this.newMessage = '';
      this.isLoading = true;
      
      // Generate a smart chat title from the first message
      if (this.messages.length === 1 && !this.chatTitle) {
        // Extract the main topic from the message
        let title = userMessage.content;
        
        // If it's too long, try to extract the main subject
        if (title.length > 30) {
          // Check for common question patterns
          if (title.toLowerCase().startsWith('how to')) {
            title = title.substring(0, Math.min(50, title.length));
          } else if (title.toLowerCase().startsWith('what')) {
            title = title.substring(0, Math.min(50, title.length));
          } else if (title.toLowerCase().startsWith('generate')) {
            const match = title.match(/generate\s+(.*?)(?:\s+for|about|on|related to|$)/i);
            if (match && match[1]) {
              title = match[1] + " ideas";
            } else {
              title = title.substring(0, Math.min(40, title.length));
            }
          } else if (title.toLowerCase().includes('ideas') || title.toLowerCase().includes('suggestions')) {
            const match = title.match(/(.*?ideas|suggestions)(?:\s+for|about|on|$)/i);
            if (match && match[1]) {
              title = match[1] + " for " + 
                (title.match(/for\s+(.*?)(?:\s+video|\s+channel|\s+content|$)/i)?.[1] || "");
            } else {
              title = title.substring(0, Math.min(40, title.length));
            }
          } else {
            // Take the first 40 chars by default, don't cut in the middle of a word
            const cutPoint = title.lastIndexOf(' ', 40);
            title = title.substring(0, cutPoint > 20 ? cutPoint : 40);
          }
        }
        
        // Add ellipsis if we shortened the title
        if (title.length < userMessage.content.length) {
          title = title.trim() + '...';
        }
        
        this.chatTitle = title;
      }
      
      try {
        const contextData = this.activeContext ? {
          type: this.activeContext.type,
          id: this.activeContext.id
        } : null;
        
        // Start der Ladeanimation
        const loadingIndicators = [
          'Generating ideas...',
          'Analyzing content...',
          'Forming creative thoughts...',
          'Checking YouTube trends...'
        ];
        
        const randomLoadingText = loadingIndicators[Math.floor(Math.random() * loadingIndicators.length)];
        
        // Zeige Ladeanimation mit Text
        const loadingMessage = {
          content: randomLoadingText,
          isUser: false,
          isLoading: true
        };
        this.messages.push(loadingMessage);
        
        // Speichere den Chat automatisch, auch wenn nur eine User-Nachricht vorhanden ist
        await this.autoSaveChat();
        
        // Versuche, die API aufzurufen
        let response;
        try {
          response = await axios.post('/chat/send', {
            prompt: userMessage.content,
            context: contextData,
            model: this.selectedAI
          });
        } catch (apiError) {
          console.error('API error:', apiError);
          
          // Entferne Ladeanimation
          this.messages = this.messages.filter(m => !m.isLoading);
          
          // Prüfe, ob es eine Antwort mit Fehlermeldung gibt
          if (apiError.response && apiError.response.data) {
            throw new Error(apiError.response.data.message || 'Error connecting to server');
          } else {
            throw new Error('Error connecting to server. Please try again later.');
          }
        }
        
        // Entferne Ladeanimation
        this.messages = this.messages.filter(m => !m.isLoading);
        
        if (response.data.success) {
          // Typing-Effekt für die Antwort
          if (this.isTypingEffect) {
            // Füge leere Nachricht hinzu, die schrittweise gefüllt wird
            const aiMessage = {
              content: '',
              fullContent: response.data.response,
              isUser: false
            };
            this.messages.push(aiMessage);
            
            // Starte Typing-Effekt
            this.startTypingEffect(this.messages.length - 1);
          } else {
            this.messages.push({
              content: response.data.response,
              isUser: false
            });
          }
          
          // Speichere den Chat automatisch
          await this.autoSaveChat();
        } else {
          throw new Error(response.data.message || 'Unknown error occurred');
        }
      } catch (error) {
        console.error('Error sending message:', error);
        
        // Benutzerfreundliche Fehlermeldung anzeigen
        const errorMessage = error.message || 'An unknown error occurred. Please try again later.';
        
        this.messages.push({
          content: `I'm sorry, an error occurred: ${errorMessage}. Try asking a different question or try again later.`,
          isUser: false
        });
        
        // Auch im Fehlerfall den Chat speichern
        await this.autoSaveChat();
      } finally {
        this.isLoading = false;
      }
    },
    async autoSaveChat() {
      console.log("=== AUTO SAVE CHAT STARTED ===");
      if (this.messages.length === 0) {
        console.log("Keine Nachrichten zum Speichern.");
        return;
      }
      
      try {
        // Get current user session
        const { data: { session } } = await supabase.auth.getSession();
        console.log("Session erhalten:", session?.user?.email);
        
        // Make sure we have a title
        if (!this.chatTitle) {
          const firstUserMessage = this.messages.find(m => m.isUser);
          if (firstUserMessage) {
            let title = firstUserMessage.content;
            // If it's too long, extract the main subject by cutting appropriately
            if (title.length > 40) {
              const cutPoint = title.lastIndexOf(' ', 40);
              title = title.substring(0, cutPoint > 20 ? cutPoint : 40) + '...';
            }
            this.chatTitle = title;
          } else {
            this.chatTitle = 'New Chat';
          }
        }
        
        // We need a logged in user to save to Supabase
        let userId;
        if (session && session.user) {
          userId = session.user.id;
          console.log('Speichere Chat in Supabase für User:', userId);
          
          // Create chat data - direkt ohne JSON.stringify
          const chatData = {
            id: this.currentChatId || uuidv4(), // Use existing ID or generate new one
            user_id: userId,
            title: this.chatTitle,
            messages: this.messages, // Direktes JSON-Objekt statt JSON.stringify
            context: this.activeContext,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          
          console.log("Chat-Daten erstellt:", chatData.id, chatData.title);
          console.log("Messages Typ:", typeof chatData.messages, Array.isArray(chatData.messages) ? 'Array' : 'Nicht-Array');
          console.log("Messages Anzahl:", chatData.messages.length);
          console.log("Beispiel-Message:", chatData.messages[0]);
          
          // Check if chat already exists in Supabase
          if (this.currentChatId) {
            console.log('Aktualisiere existierenden Chat in Supabase:', this.currentChatId);
            // Update existing chat
            const { data, error } = await supabase
              .from('idea_chats')
              .update({
                title: chatData.title,
                messages: chatData.messages,
                context: chatData.context,
                updated_at: chatData.updated_at
              })
              .eq('id', this.currentChatId)
              .eq('user_id', userId);
            
            if (error) {
              console.error('Fehler beim Aktualisieren des Chats in Supabase:', error);
              
              // Zeige Fehlerdetails
              console.log("Fehlercode:", error.code);
              console.log("Fehlermeldung:", error.message);
              if (error.details) console.log("Fehlerdetails:", error.details);
              
              // If the chat doesn't exist yet (first save), insert it
              console.log('Versuche Insert nach fehlgeschlagenem Update');
              const { data: insertData, error: insertError } = await supabase
                .from('idea_chats')
                .insert([chatData]);
              
              if (insertError) {
                console.error('Fehler beim Einfügen des Chats nach fehlgeschlagenem Update:', insertError);
                console.log("Insert-Fehlercode:", insertError.code);
                console.log("Insert-Fehlermeldung:", insertError.message);
                if (insertError.details) console.log("Insert-Fehlerdetails:", insertError.details);
                throw insertError;
              } else {
                console.log('Chat erfolgreich eingefügt nach fehlgeschlagenem Update');
              }
              
              // Save the new chat ID
              this.currentChatId = chatData.id;
            } else {
              console.log('Chat erfolgreich in Supabase aktualisiert');
            }
          } else {
            console.log('Füge neuen Chat in Supabase ein');
            // Insert new chat
            const { data, error } = await supabase
              .from('idea_chats')
              .insert([chatData]);
            
            if (error) {
              console.error('Fehler beim Einfügen des neuen Chats in Supabase:', error);
              console.log("Fehlercode:", error.code);
              console.log("Fehlermeldung:", error.message);
              if (error.details) console.log("Fehlerdetails:", error.details);
              throw error;
            } else {
              console.log('Neuer Chat erfolgreich in Supabase eingefügt');
            }
            
            // Save the new chat ID
            this.currentChatId = chatData.id;
          }
          
          // Also save to localStorage as backup
          let savedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
          const localChatData = {
            id: chatData.id,
            user_id: userId,
            title: chatData.title,
            messages: this.messages,
            context: this.activeContext,
            date: chatData.updated_at
          };
          
          // Update or add to local storage
          const existingChatIndex = savedChats.findIndex(c => c.id === localChatData.id);
          if (existingChatIndex >= 0) {
            savedChats[existingChatIndex] = localChatData;
          } else {
            savedChats.unshift(localChatData);
          }
          localStorage.setItem('chatHistory', JSON.stringify(savedChats));
          console.log('Saved chat to localStorage as backup');
          
        } else {
          // No logged in user, fall back to localStorage only
          userId = sessionStorage.getItem('temp_user_id') || this.generateTempUserId();
          console.log('No user session, saving to localStorage only with temp ID:', userId);
          
          // Create chat data for localStorage
          const chatData = {
            id: this.currentChatId || uuidv4(),
            user_id: userId,
            title: this.chatTitle,
            messages: this.messages,
            context: this.activeContext,
            date: new Date().toISOString()
          };
          
          // Save to localStorage
          let savedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
          
          // Check if there's an existing chat to update
          const existingChatIndex = savedChats.findIndex(c => c.id === chatData.id);
          if (existingChatIndex >= 0) {
            // Update existing chat
            savedChats[existingChatIndex] = chatData;
          } else {
            // Add new chat
            savedChats.unshift(chatData);
            // Save the new chat ID
            this.currentChatId = chatData.id;
          }
          
          localStorage.setItem('chatHistory', JSON.stringify(savedChats));
        }
        
        // Update chat history
        await this.loadChatHistory();
        
        // Update URL if needed (only when first creating the chat)
        if (this.$route.name !== 'specific-chat' && this.currentChatId) {
          this.$router.push({ 
            name: 'specific-chat', 
            params: { chatId: this.currentChatId }
          }).catch(err => {
            if (err.name !== 'NavigationDuplicated') {
              console.error('Navigation error:', err);
            }
          });
        }
      } catch (error) {
        console.error('Error auto-saving chat:', error);
      }
    },
    scrollToBottom() {
      const chatContainer = document.querySelector('.chat-messages');
      if (chatContainer) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
    },
    detectMobile() {
      this.isMobile = window.innerWidth < 768;
      if (this.isMobile) {
        this.mobileMenuOpen = false;
      }
    },
    toggleTheme() {
      this.themePreference = this.themePreference === 'light' ? 'dark' : 'light';
    },
    formatMessageContent(content) {
      // Zuerst Markdown zu HTML konvertieren
      let html = marked(content);
      
      // Emojis konvertieren
      html = emojione.toImage(html);
      
      // HTML säubern, um XSS zu verhindern
      html = DOMPurify.sanitize(html);
      
      return html;
    },
    startTypingEffect(messageIndex) {
      if (this.typing) {
        clearInterval(this.typing);
      }
      
      const message = this.messages[messageIndex];
      const fullContent = message.fullContent;
      let typeIndex = 0;
      
      this.typing = setInterval(() => {
        if (typeIndex < fullContent.length) {
          // Füge jeweils einen Buchstaben hinzu
          this.messages[messageIndex].content = fullContent.substring(0, typeIndex + 1);
          typeIndex++;
        } else {
          // Stoppe den Effekt, wenn fertig
          clearInterval(this.typing);
        }
      }, 10);  // Schnelle Geschwindigkeit für realistische Darstellung
    },
    toggleMobileMenu() {
      this.mobileMenuOpen = !this.mobileMenuOpen;
    },
    toggleTypingEffect() {
      this.isTypingEffect = !this.isTypingEffect;
      localStorage.setItem('typingEffect', this.isTypingEffect);
    },
    toggleAutoScroll() {
      this.autoScrollEnabled = !this.autoScrollEnabled;
      localStorage.setItem('autoScroll', this.autoScrollEnabled);
    },
    handleKeyboardShortcuts(e) {
      // Strg+Enter zum Senden
      if (e.ctrlKey && e.key === 'Enter') {
        this.sendMessage();
        e.preventDefault();
      }
      
      // Esc zum Schließen von Popups
      if (e.key === 'Escape') {
        this.showPromptLibrary = false;
        this.showTitleEdit = false;
        this.showChatHistory = false;
        this.showContextDropdown = false;
        e.preventDefault();
      }
    },
    toggleContextDropdown() {
      this.showContextDropdown = !this.showContextDropdown;
    },
    selectContext(type, id, name) {
      this.activeContext = {
        type,
        id,
        name
      };
      this.showContextDropdown = false;
    },
    clearContext() {
      this.activeContext = null;
    },
    openPromptLibrary() {
      this.showPromptLibrary = true;
      this.selectedCategory = null;
    },
    selectPromptCategory(category) {
      this.selectedCategory = category;
    },
    usePrompt(prompt) {
      this.newMessage = prompt.content;
      this.showPromptLibrary = false;
      this.selectedCategory = null;
      // Focus on textarea
      this.$nextTick(() => {
        document.querySelector('textarea').focus();
      });
    },
    useExample(exampleText) {
      this.newMessage = exampleText;
      this.sendMessage();
    },
    getModelName(modelId) {
      switch (modelId) {
        case 'gpt': return 'GPT-4';
        case 'gpt3': return 'GPT-3.5 Turbo';
        case 'claude': return 'Claude 3';
        case 'deepseek': return 'DeepSeek';
        default: return 'KI-Modell';
      }
    },
    handleOutsideClick(event) {
      // Close model selector if clicking outside
      if (this.showModelSelector && !event.target.closest('.model-selector')) {
        this.showModelSelector = false;
      }
      
      // Close context dropdown if clicking outside
      if (this.showContextDropdown && !event.target.closest('.context-button') && !event.target.closest('.context-dropdown')) {
        this.showContextDropdown = false;
      }
    },
    async loadChatById(chatId) {
      if (!chatId) return false;
      
      try {
        // Get current user session
        const { data: { session } } = await supabase.auth.getSession();
        
        // First check if we already have this chat loaded
        if (this.currentChatId === chatId && this.messages.length > 0) {
          return true;
        }
        
        if (session?.user?.id) {
          // Try to load from Supabase first
          const { data: chat, error } = await supabase
            .from('idea_chats')
            .select('*')
            .eq('id', chatId)
            .eq('user_id', session.user.id)
            .single();
          
          if (!error && chat) {
            // Set all chat data
            this.messages = JSON.parse(chat.messages);
            this.chatTitle = chat.title || 'Untitled Chat';
            this.activeContext = chat.context ? JSON.parse(chat.context) : null;
            this.currentChatId = chat.id;
            
            console.log('Loaded chat from Supabase:', chat.id, chat.title);
            return true;
          }
        }
        
        // Fall back to localStorage if not found in Supabase
        const currentUserId = session?.user?.id || 
          sessionStorage.getItem('temp_user_id') || 
          this.generateTempUserId();
        
        const chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
        const localChat = chatHistory.find(c => c.id === chatId);
        
        // Verify the chat belongs to the current user
        if (localChat && (localChat.user_id === currentUserId || !localChat.user_id)) {
          // Set all chat data
          this.messages = localChat.messages || [];
          this.chatTitle = localChat.title || 'Untitled Chat';
          this.activeContext = localChat.context || null;
          this.currentChatId = localChat.id;
          
          console.log('Loaded chat from localStorage:', localChat.id, localChat.title);
          return true;
        }
        
        console.warn('Chat not found:', chatId);
        return false;
      } catch (error) {
        console.error('Error loading chat by ID:', error);
        return false;
      }
    },
    clearCurrentChat() {
      // Only clear if we have a current chat
      if (this.messages.length > 0 || this.currentChatId) {
        this.messages = [];
        this.chatTitle = '';
        this.activeContext = null;
        this.currentChatId = null;
      }
    },
    confirmDeleteChat(chat) {
      this.chatToDelete = chat;
      this.showDeleteConfirm = true;
    },
    cancelDeleteChat() {
      this.showDeleteConfirm = false;
      this.chatToDelete = null;
    },
    async confirmAndDeleteChat() {
      if (!this.chatToDelete) return;
      
      try {
        console.log('Deleting chat:', this.chatToDelete.id);
        const { data: { session } } = await supabase.auth.getSession();
        
        if (session?.user?.id) {
          console.log('Deleting from Supabase for user:', session.user.id);
          // Delete from Supabase
          const { error } = await supabase
            .from('idea_chats')
            .delete()
            .eq('id', this.chatToDelete.id)
            .eq('user_id', session.user.id);
          
          if (error) {
            console.error('Error deleting chat from Supabase:', error);
            throw error;
          } else {
            console.log('Successfully deleted chat from Supabase');
          }
        } else {
          console.log('No user session, only deleting from localStorage');
        }
        
        // Also update localStorage
        let savedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
        const chatCountBefore = savedChats.length;
        savedChats = savedChats.filter(c => c.id !== this.chatToDelete.id);
        const chatCountAfter = savedChats.length;
        console.log(`Removed ${chatCountBefore - chatCountAfter} chat(s) from localStorage`);
        
        localStorage.setItem('chatHistory', JSON.stringify(savedChats));
        
        // Update the local chat history
        await this.loadChatHistory();
        
        // If the deleted chat is the current chat, clear the current chat
        if (this.currentChatId === this.chatToDelete.id) {
          console.log('Deleted the current active chat, clearing and redirecting');
          this.clearCurrentChat();
          this.$router.push({ name: 'idea-chat' });
        }
        
        // Close the confirmation dialog
        this.showDeleteConfirm = false;
        this.chatToDelete = null;
      } catch (error) {
        console.error('Error deleting chat:', error);
        alert('Failed to delete chat: ' + error.message);
      }
    },
    openChannelLink(message) {
      // Implement the logic to open a channel link
      console.log('Opening channel link:', message);
      alert('Channel link functionality will be implemented');
    },
    openScriptLink(message) {
      // Implement the logic to open a script link
      console.log('Opening script link:', message);
      alert('Script link functionality will be implemented');
    },
    async loadChatHistory() {
      try {
        // Get current user session
        const { data: { session } } = await supabase.auth.getSession();
        
        if (session && session.user) {
          console.log('Loading chats from Supabase for user:', session.user.id);
          // Logged in user - Get chats from Supabase
          const { data: supabaseChats, error } = await supabase
            .from('idea_chats')
            .select('*')
            .eq('user_id', session.user.id)
            .order('updated_at', { ascending: false });
          
          if (error) {
            console.error('Error fetching chats from Supabase:', error);
            throw error;
          }
          
          if (supabaseChats) {
            console.log('Loaded', supabaseChats.length, 'chats from Supabase');
            // Format the chats from Supabase - KEINE JSON-Konvertierung nötig
            this.chatHistory = supabaseChats.map(chat => ({
              id: chat.id,
              user_id: chat.user_id,
              title: chat.title,
              messages: chat.messages,  // Direkt verwenden, keine Konvertierung
              context: chat.context,    // Direkt verwenden, keine Konvertierung
              date: chat.updated_at
            }));
          } else {
            console.log('No chats found in Supabase');
            this.chatHistory = [];
          }
        } else {
          console.log('No user session, loading from localStorage only');
          // Not logged in - Use localStorage
          const allSavedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
          const tempUserId = sessionStorage.getItem('temp_user_id') || this.generateTempUserId();
          this.chatHistory = allSavedChats.filter(chat => 
            !chat.user_id || chat.user_id === tempUserId
          );
          console.log('Loaded', this.chatHistory.length, 'chats from localStorage');
        }
      } catch (error) {
        console.error('Error loading chat history:', error);
        // Fallback to localStorage
        try {
          console.log('Falling back to localStorage');
          const allSavedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
          this.chatHistory = allSavedChats;
          console.log('Loaded', this.chatHistory.length, 'chats from localStorage as fallback');
        } catch (e) {
          console.error('Failed to fall back to localStorage:', e);
          this.chatHistory = [];
        }
      }
    },
    generateTempUserId() {
      // Generate a temporary user ID for non-logged in users
      let tempId = sessionStorage.getItem('temp_user_id');
      if (!tempId) {
        tempId = 'temp_' + uuidv4();
        sessionStorage.setItem('temp_user_id', tempId);
      }
      return tempId;
    },
    loadChat(chat) {
      // Load a saved chat
      this.messages = chat.messages;
      this.chatTitle = chat.title;
      this.activeContext = chat.context;
      this.currentChatId = chat.id;
      
      // Update the URL to reflect the loaded chat ID
      if (this.$route.params.chatId !== chat.id) {
        this.$router.push({ 
          name: 'specific-chat', 
          params: { chatId: chat.id }
        }).catch(err => {
          if (err.name !== 'NavigationDuplicated') {
            console.error('Navigation error:', err);
          }
        });
      }
      
      // Close the modal
      this.showChatHistory = false;
    },
    formatDate(dateString) {
      if (!dateString) return '';
      
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('de-DE', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).format(date);
    },
    isChatActive(chat) {
      return this.currentChatId === chat.id;
    },
    switchAI(model) {
      this.selectedAI = model;
    },
    editChatTitle() {
      this.editedTitle = this.chatTitle;
      this.showTitleEdit = true;
    },
    saveChatTitle() {
      this.chatTitle = this.editedTitle;
      this.showTitleEdit = false;
      this.saveChat(); // Speichere den Chat mit dem neuen Titel
    },
    async startNewChat() {
      // Clear current chat data
      this.clearCurrentChat();
      
      // Generate a new chat ID
      this.currentChatId = uuidv4();
      
      // Ensure we have a user id (either real or temporary)
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.user?.id) {
        const tempUserId = sessionStorage.getItem('temp_user_id') || this.generateTempUserId();
        sessionStorage.setItem('temp_user_id', tempUserId);
      }
      
      // Navigate to the new chat URL
      this.$router.push({ path: `/idea-chat/${this.currentChatId}` });
      
      return this.currentChatId;
    },
    async saveChat(silent = false) {
      if (this.messages.length === 0) return Promise.resolve(false);
      
      try {
        // Get current user session
        const { data: { session } } = await supabase.auth.getSession();
        
        // Make sure we have a title
        if (!this.chatTitle) {
          const firstUserMessage = this.messages.find(m => m.isUser);
          if (firstUserMessage) {
            let title = firstUserMessage.content;
            // If it's too long, extract the main subject by cutting appropriately
            if (title.length > 40) {
              const cutPoint = title.lastIndexOf(' ', 40);
              title = title.substring(0, cutPoint > 20 ? cutPoint : 40) + '...';
            }
            this.chatTitle = title;
          } else {
            this.chatTitle = 'New Chat';
          }
        }
        
        // We need a logged in user to save to Supabase
        let userId;
        let savedToSupabase = false;
        
        if (session && session.user) {
          userId = session.user.id;
          
          // Create chat data
          const chatData = {
            id: this.currentChatId || uuidv4(), // Use existing ID or generate new one
            user_id: userId,
            title: this.chatTitle,
            messages: this.messages, // Direktes JSON-Objekt statt JSON.stringify
            context: this.activeContext,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          
          // Check if chat already exists in Supabase
          if (this.currentChatId) {
            // Update existing chat
            const { data, error } = await supabase
              .from('idea_chats')
              .update({
                title: chatData.title,
                messages: chatData.messages,
                context: chatData.context,
                updated_at: chatData.updated_at
              })
              .eq('id', this.currentChatId)
              .eq('user_id', userId);
            
            if (error) {
              // If the chat doesn't exist yet (first save), insert it
              const { data: insertData, error: insertError } = await supabase
                .from('idea_chats')
                .insert([chatData]);
              
              if (insertError) throw insertError;
              savedToSupabase = true;
            } else {
              savedToSupabase = true;
            }
          } else {
            // Insert new chat
            const { data, error } = await supabase
              .from('idea_chats')
              .insert([chatData]);
            
            if (error) throw error;
            savedToSupabase = true;
            
            // Save the new chat ID
            this.currentChatId = chatData.id;
          }
        } else {
          // No logged in user, fall back to localStorage only
          userId = sessionStorage.getItem('temp_user_id') || this.generateTempUserId();
        }
        
        // Always save to localStorage as backup
        let savedChats = JSON.parse(localStorage.getItem('chatHistory') || '[]');
        
        // Create chat data for localStorage
        const localChatData = {
          id: this.currentChatId || uuidv4(),
          user_id: userId,
          title: this.chatTitle,
          messages: this.messages,
          context: this.activeContext,
          date: new Date().toISOString()
        };
        
        // Check if there's an existing chat to update
        const existingChatIndex = savedChats.findIndex(c => c.id === localChatData.id);
        if (existingChatIndex >= 0) {
          // Update existing chat
          savedChats[existingChatIndex] = localChatData;
        } else {
          // Add new chat
          savedChats.unshift(localChatData);
          // Save the new chat ID if not already set
          if (!this.currentChatId) {
            this.currentChatId = localChatData.id;
          }
        }
        
        localStorage.setItem('chatHistory', JSON.stringify(savedChats));
        
        // Update chat history
        await this.loadChatHistory();
        
        // Update URL if needed (only when first creating the chat)
        if (this.$route.name !== 'specific-chat' && this.currentChatId) {
          this.$router.push({ 
            name: 'specific-chat', 
            params: { chatId: this.currentChatId }
          }).catch(err => {
            if (err.name !== 'NavigationDuplicated') {
              console.error('Navigation error:', err);
            }
          });
        }
        
        // Show success message unless silent is true
        if (!silent) {
          if (savedToSupabase) {
            alert('Chat saved to database successfully');
          } else {
            alert('Chat saved to local storage (login to save to database)');
          }
        }
        
        return Promise.resolve(true);
      } catch (error) {
        console.error('Error saving chat:', error);
        if (!silent) {
          alert('Error saving chat: ' + error.message);
        }
        return Promise.resolve(false);
      }
    },
    shareChat() {
      if (this.messages.length === 0) {
        alert('There is nothing to share.');
        return;
      }
      
      // Save the chat first to ensure it has an ID
      this.saveChat(true).then(() => {
        if (this.currentChatId) {
          // Create the shareable URL
          const shareableUrl = `${window.location.origin}/idea-chat/${this.currentChatId}`;
          
          // Copy to clipboard
          navigator.clipboard.writeText(shareableUrl)
            .then(() => {
              alert('Chat link copied to clipboard. You can now share it with others.');
            })
            .catch(err => {
              alert(`Share link: ${shareableUrl}`);
              console.error('Could not copy to clipboard:', err);
            });
        }
      });
    },
    // Add new method to detect and set navbar height
    setNavbarHeight() {
      // Get navbar element - adjust selector to match your navbar
      const navbar = document.querySelector('nav') || document.querySelector('.navbar');
      if (navbar) {
        const navbarHeight = navbar.offsetHeight;
        document.documentElement.style.setProperty('--navbar-height', `${navbarHeight}px`);
      }
    },
    // Placeholder that calls the confirmation
    deleteChat(chat) {
      this.confirmDeleteChat(chat);
    },
    formatTime(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleTimeString() + ' ' + date.toLocaleDateString();
    },
    async forceSyncWithSupabase() {
      if (!this.supabaseStatus.loggedIn || !this.supabaseStatus.tableExists) {
        alert('Bitte einloggen und sicherstellen, dass die Tabelle existiert');
        return;
      }
      
      this.supabaseStatus.syncInProgress = true;
      this.supabaseStatus.message = 'Synchronisiere...';
      
      try {
        // Aktueller Chat speichern, falls vorhanden
        if (this.messages.length > 0) {
          await this.autoSaveChat();
        }
        
        // Alle Chats aus Supabase laden
        const { data: supabaseChats, error } = await supabase
          .from('idea_chats')
          .select('*')
          .eq('user_id', this.supabaseStatus.userId)
          .order('updated_at', { ascending: false });
        
        if (error) {
          throw error;
        }
        
        // Chats verarbeiten und in localStorage speichern
        if (supabaseChats && supabaseChats.length > 0) {
          const formattedChats = supabaseChats.map(chat => ({
            id: chat.id,
            user_id: chat.user_id,
            title: chat.title,
            messages: chat.messages, // Direkt das JSON-Objekt verwenden
            context: chat.context,
            date: chat.updated_at
          }));
          
          // In localStorage speichern
          localStorage.setItem('chatHistory', JSON.stringify(formattedChats));
          
          // Chat-Historie aktualisieren
          this.chatHistory = formattedChats;
          
          this.supabaseStatus.lastSync = new Date();
          this.supabaseStatus.lastSyncResult = `Erfolgreich (${formattedChats.length} Chats)`;
          this.supabaseStatus.message = 'Synchronisation erfolgreich';
        } else {
          this.supabaseStatus.lastSync = new Date();
          this.supabaseStatus.lastSyncResult = 'Keine Chats gefunden';
          this.supabaseStatus.message = 'Keine Chats in der Cloud gefunden';
        }
      } catch (error) {
        console.error('Sync error:', error);
        this.supabaseStatus.error = error.message;
        this.supabaseStatus.lastSync = new Date();
        this.supabaseStatus.lastSyncResult = 'Fehler: ' + error.message;
        this.supabaseStatus.message = 'Synchronisation fehlgeschlagen';
      } finally {
        this.supabaseStatus.syncInProgress = false;
      }
    },
    async createSupabaseTable() {
      // Login-Check entfernt
      this.supabaseStatus.message = 'Erstelle Tabelle...';
      
      try {
        // Verbindungsprüfung
        const { data: { session } } = await supabase.auth.getSession();
        
        if (!session) {
          this.supabaseStatus.message = 'Nicht eingeloggt, aber versuche trotzdem...';
          console.warn('Nicht eingeloggt bei dem Versuch, die Tabelle zu erstellen');
        }
        
        // SQL zur Tabellenerstellung ausführen
        const { error } = await supabase.rpc('create_idea_chats_table');
        
        if (error) {
          throw error;
        }
        
        this.supabaseStatus.tableExists = true;
        this.supabaseStatus.message = 'Tabelle erfolgreich erstellt';
        this.supabaseStatus.error = null;
      } catch (error) {
        console.error('Error creating table:', error);
        this.supabaseStatus.error = error.message;
        this.supabaseStatus.message = 'Fehler beim Erstellen der Tabelle';
        
        // Alternativer Ansatz mit SQL-Anzeige
        alert('Möglicherweise musst du das SQL-Skript manuell in der Supabase SQL-Konsole ausführen. Fehler: ' + error.message);
      }
    },
    async testSaveChat() {
      this.debugInfo = "Versuche, Test-Chat zu speichern...";
      
      try {
        // Prüfe, ob wir eingeloggt sind
        const { data: { session } } = await supabase.auth.getSession();
        
        let userId;
        if (session && session.user) {
          userId = session.user.id;
          this.debugInfo += "\nEingeloggt als: " + session.user.email;
        } else {
          // Anonymer Test-Benutzer
          userId = 'anon-' + uuidv4().substring(0, 8);
          this.debugInfo += "\nNicht eingeloggt, verwende temporäre ID: " + userId;
        }
        
        // Erstelle einen Test-Chat
        const testChat = {
          id: uuidv4(),
          user_id: userId,
          title: "Test Chat " + new Date().toLocaleTimeString(),
          messages: [
            { content: "Test message", isUser: true },
            { content: "Test response", isUser: false }
          ],
          context: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        
        this.debugInfo += `\nTest-Chat erstellt mit ID: ${testChat.id}`;
        this.debugInfo += `\nUser ID: ${userId}`;
        
        // Direktes Einfügen in die Datenbank - Vereinfachte Version ohne JSON.stringify
        this.debugInfo += "\nFüge in Supabase ein...";
        const { data, error } = await supabase
          .from('idea_chats')
          .insert([testChat]);
        
        if (error) {
          this.debugInfo += "\nFehler beim Speichern: " + error.message;
          console.error("Error saving test chat:", error);
          
          // Weitere Fehlerdetails
          if (error.details) {
            this.debugInfo += "\nFehlerdetails: " + error.details;
          }
          
          // Überprüfe auf häufige Fehler
          if (error.code === "23503") {
            this.debugInfo += "\nReferenzfehler: Möglicherweise ein Problem mit der user_id oder dem Fremdschlüssel.";
          } else if (error.code === "42P01") {
            this.debugInfo += "\nTabelle existiert nicht. Bitte erstelle die Tabelle.";
          } else if (error.code === "42703") {
            this.debugInfo += "\nSpalte existiert nicht. Tabellenschema könnte fehlerhaft sein.";
          } else if (error.code === "22P02") {
            this.debugInfo += "\nUngültiger JSON-Typ. Überprüfe die JSON-Struktur der Nachricht.";
          }
        } else {
          this.debugInfo += "\nTest-Chat erfolgreich gespeichert!";
          
          // Lade die Chats neu
          await this.loadChatHistory();
          this.debugInfo += "\nChat-Historie neu geladen.";
        }
      } catch (error) {
        this.debugInfo += "\nAllgemeiner Fehler: " + error.message;
        console.error("General error in testSaveChat:", error);
      }
    },
    
    async checkChatTable() {
      this.debugInfo = "Überprüfe idea_chats Tabelle...";
      
      try {
        // Prüfe, ob der Benutzer eingeloggt ist
        const { data: { session } } = await supabase.auth.getSession();
        
        if (!session || !session.user) {
          this.debugInfo += "\nNicht eingeloggt. Bitte einloggen.";
          return;
        }
        
        // Tabellenschema überprüfen
        this.debugInfo += "\nRufe Tabellenschema ab...";
        
        const { data: tableData, error: tableError } = await supabase
          .from('idea_chats')
          .select('*')
          .limit(0);
        
        if (tableError) {
          this.debugInfo += "\nFehler beim Prüfen der Tabelle: " + tableError.message;
          console.error("Error checking table:", tableError);
          return;
        }
        
        this.debugInfo += "\nTabelle existiert und ist zugänglich.";
        
        // Anzahl der Einträge abrufen
        const { count, error: countError } = await supabase
          .from('idea_chats')
          .select('*', { count: 'exact', head: true });
        
        if (countError) {
          this.debugInfo += "\nFehler beim Zählen der Einträge: " + countError.message;
        } else {
          this.debugInfo += `\nAnzahl der Einträge in der Tabelle: ${count || 0}`;
        }
        
        // Prüfe spezifisch für den aktuellen Benutzer
        const { data: userChats, error: userChatsError } = await supabase
          .from('idea_chats')
          .select('id, title, updated_at')
          .eq('user_id', session.user.id);
        
        if (userChatsError) {
          this.debugInfo += "\nFehler beim Abrufen der Benutzer-Chats: " + userChatsError.message;
        } else if (userChats && userChats.length > 0) {
          this.debugInfo += `\nGefundene Chats für Benutzer: ${userChats.length}`;
          this.debugInfo += "\nChats:";
          userChats.forEach((chat, index) => {
            this.debugInfo += `\n${index + 1}. ${chat.title} (ID: ${chat.id.substring(0, 8)}...) - ${new Date(chat.updated_at).toLocaleString()}`;
          });
        } else {
          this.debugInfo += "\nKeine Chats für den aktuellen Benutzer gefunden.";
        }
        
        // Überprüfe, ob die RLS-Richtlinien korrekt eingerichtet sind
        this.debugInfo += "\nRLS-Richtlinien können nicht direkt überprüft werden.";
        
      } catch (error) {
        this.debugInfo += "\nAllgemeiner Fehler: " + error.message;
        console.error("General error in checkChatTable:", error);
      }
    },
    // Nach der testSaveChat-Methode
    async dumpSupabaseState() {
      this.debugInfo = "Dumping Supabase state...";
      
      try {
        console.log("=== SUPABASE STATUS DUMP ===");
        
        // 1. Prüfe Session und Benutzer
        const { data: { session } } = await supabase.auth.getSession();
        console.log("Session:", session);
        
        if (session && session.user) {
          console.log("Logged in as:", session.user.email);
          console.log("User ID:", session.user.id);
          
          // 2. Prüfe, ob die Tabelle existiert
          const { data: tableInfo, error: tableError } = await supabase
            .from('idea_chats')
            .select('*')
            .limit(1);
          
          console.log("Table exists:", tableError ? "NO" : "YES");
          if (tableError) {
            console.error("Table error:", tableError);
          }
          
          // 3. Prüfe vorhandene Chats
          const { data: chats, error: chatsError } = await supabase
            .from('idea_chats')
            .select('id, title, updated_at')
            .eq('user_id', session.user.id);
          
          console.log("User chats found:", chats ? chats.length : 0);
          if (chats && chats.length) {
            console.log("Chats:", chats);
          }
          if (chatsError) {
            console.error("Chats error:", chatsError);
          }
          
          // 4. Versuche einen einfachen Test-Insert
          const testId = uuidv4();
          const simpleTestData = {
            id: testId,
            user_id: session.user.id,
            title: "Simple Test " + new Date().toLocaleTimeString(),
            messages: [{ content: "Simple test", isUser: true }],
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
          
          console.log("Attempting simple insert:", simpleTestData);
          
          const { data: insertData, error: insertError } = await supabase
            .from('idea_chats')
            .insert([simpleTestData]);
          
          console.log("Insert result:", insertError ? "FAILED" : "SUCCESS");
          if (insertError) {
            console.error("Insert error:", insertError);
            this.debugInfo += "\nEinfügen fehlgeschlagen: " + insertError.message;
            if (insertError.details) {
              this.debugInfo += "\nDetails: " + insertError.details;
            }
          } else {
            this.debugInfo += "\nEinfügen erfolgreich! ID: " + testId;
            
            // 5. Versuche den eingefügten Datensatz zu lesen
            const { data: readData, error: readError } = await supabase
              .from('idea_chats')
              .select('*')
              .eq('id', testId);
            
            console.log("Read result:", readError ? "FAILED" : "SUCCESS");
            if (readError) {
              console.error("Read error:", readError);
              this.debugInfo += "\nLesen fehlgeschlagen: " + readError.message;
            } else if (readData && readData.length) {
              console.log("Retrieved data:", readData[0]);
              this.debugInfo += "\nLesen erfolgreich! Daten erhalten.";
            } else {
              console.log("No data found for ID:", testId);
              this.debugInfo += "\nKeine Daten für ID " + testId + " gefunden.";
            }
          }
        } else {
          console.log("Not logged in");
          this.debugInfo += "\nNicht eingeloggt. Bitte einloggen.";
        }
        
        console.log("=== END SUPABASE STATUS DUMP ===");
      } catch (error) {
        console.error("Error in dumpSupabaseState:", error);
        this.debugInfo += "\nFehler: " + error.message;
      }
    },
  }
};
</script> 

<style>
/* Markdown Styling */
.markdown-content h1 {
  font-size: 1.5rem;
  font-weight: bold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
}

.markdown-content h2 {
  font-size: 1.25rem;
  font-weight: bold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
}

.markdown-content h3 {
  font-size: 1.1rem;
  font-weight: bold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
}

.markdown-content p {
  margin-bottom: 0.75rem;
}

.markdown-content ul, .markdown-content ol {
  margin-left: 1.5rem;
  margin-bottom: 1rem;
}

.markdown-content ul {
  list-style-type: disc;
}

.markdown-content ol {
  list-style-type: decimal;
}

.markdown-content li {
  margin-bottom: 0.25rem;
}

.markdown-content code {
  font-family: monospace;
  background-color: rgba(0,0,0,0.05);
  padding: 0.1rem 0.3rem;
  border-radius: 0.25rem;
}

.dark .markdown-content code {
  background-color: rgba(255,255,255,0.1);
}

.markdown-content pre {
  background-color: rgba(0,0,0,0.05);
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
  margin-bottom: 1rem;
}

.dark .markdown-content pre {
  background-color: rgba(0,0,0,0.3);
}

.markdown-content a {
  color: #4f46e5;
  text-decoration: underline;
}

.dark .markdown-content a {
  color: #818cf8;
}

.markdown-content blockquote {
  border-left: 4px solid #e5e7eb;
  padding-left: 1rem;
  margin-left: 0;
  margin-right: 0;
  font-style: italic;
}

.dark .markdown-content blockquote {
  border-left-color: #4b5563;
}

.markdown-content table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 1rem;
}

.markdown-content table th,
.markdown-content table td {
  border: 1px solid #e5e7eb;
  padding: 0.5rem;
  text-align: left;
}

.dark .markdown-content table th,
.dark .markdown-content table td {
  border-color: #4b5563;
}

.markdown-content table th {
  background-color: rgba(0,0,0,0.05);
}

.dark .markdown-content table th {
  background-color: rgba(255,255,255,0.05);
}

/* Auto-resize Textarea */
textarea {
  overflow: hidden;
  min-height: 48px;
  max-height: 200px;
  line-height: 1.5;
}

/* Transition Animations */
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

/* Mobile Optimizations */
@media (max-width: 640px) {
  .markdown-content {
    font-size: 0.95rem;
  }
}

/* Typing indicator animation */
.typing-indicator {
  display: flex;
  align-items: center;
}

.typing-indicator span {
  height: 8px;
  width: 8px;
  margin: 0 2px;
  background-color: #a0aec0;
  border-radius: 50%;
  display: inline-block;
  animation: typing 1.4s infinite ease-in-out both;
}

.typing-indicator span:nth-child(1) {
  animation-delay: 0s;
}

.typing-indicator span:nth-child(2) {
  animation-delay: 0.3s;
}

.typing-indicator span:nth-child(3) {
  animation-delay: 0.6s;
}

@keyframes typing {
  0%, 80%, 100% { transform: scale(0.6); opacity: 0.6; }
  40% { transform: scale(1); opacity: 1; }
}

/* Dark mode adjustments */
.dark .prose {
  color: #e2e8f0;
}

.dark .prose a {
  color: #93c5fd;
}

.dark .prose strong {
  color: #f3f4f6;
}

.dark .prose code {
  background-color: rgba(55, 65, 81, 0.5);
  color: #e5e7eb;
}

.dark .prose pre {
  background-color: #1e293b;
}

/* Fade in animation for messages */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-messages > div > div {
  animation: fadeIn 0.3s ease-out;
}

/* === LAYOUT FIXES === */
/* Set body to allow scrolling, but control it at component level */
body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow-y: auto;
}

/* Container sizing that doesn't cut off content */
.h-app-content {
  min-height: calc(100vh - 60px);
  display: flex;
}

/* Main chat container */
.flex-1.flex.flex-col.overflow-hidden {
  display: flex;
  flex-direction: column;
  min-height: calc(100vh - 60px);
}

/* Make chat messages properly scrollable */
.chat-messages {
  overflow-y: auto;
  overflow-x: hidden;
  flex: 1 1 auto;
  padding: 0.75rem 0.5rem;
  min-height: 150px; /* Ensure minimum height for content */
}

/* Fix input area styling */
.flex-shrink-0 {
  flex: 0 0 auto;
  border-top: 1px solid rgb(229, 231, 235);
  background-color: white;
  padding: 0.5rem 1rem;
}

.dark .flex-shrink-0 {
  border-color: rgb(55, 65, 81);
  background-color: rgb(31, 41, 55);
}

/* Support for full height content when needed */
.h-full {
  height: 100%;
  min-height: 0;
}

/* Fix sizing for empty state container */
.flex.flex-col.items-center.justify-start.h-full {
  padding-top: 2rem;
  padding-bottom: 2rem;
}

/* New fixed layout solution with flexible navbar height */
.chat-container {
  position: fixed;
  top: var(--navbar-height, 60px); /* Use CSS variable with fallback */
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  background-color: #f8fafc;
}

.dark .chat-container {
  background-color: rgb(17, 24, 39);
}

.chat-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #f8fafc;
}

.dark .chat-main {
  background-color: rgb(17, 24, 39);
}

.chat-header {
  background-color: white;
  border-bottom: 1px solid rgb(229, 231, 235);
  padding: 1rem;
  z-index: 10;
}

.dark .chat-header {
  background-color: rgb(31, 41, 55);
  border-color: rgb(55, 65, 81);
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 1.75rem 1rem;
  background-color: #f8fafc;
}

.dark .chat-messages {
  background-color: rgb(17, 24, 39);
}

.chat-input {
  background-color: white;
  border-top: 1px solid rgb(229, 231, 235);
  padding: 0.75rem 1.5rem 1.25rem 1.5rem;
  z-index: 10;
}

.dark .chat-input {
  background-color: rgb(31, 41, 55);
  border-color: rgb(55, 65, 81);
}

/* Sidebar width and limit for titles */
.w-80 {
  min-width: 200px !important;
  max-width: 320px !important;
}

/* Limit titles in the chat sidebar */
.chat-container > div > div > div.space-y-1 > div > p {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: calc(100% - 28px); /* Account for delete button */
}

/* Make delete button fixed width */
.chat-container > div > div > div.space-y-1 > div > button {
  flex-shrink: 0;
  width: 24px;
  margin-left: 4px;
}

/* More specific selectors for the sidebar chat items */
.flex.items-center.justify-between.px-3.py-2.rounded-md.cursor-pointer {
  display: flex;
  align-items: center;
  width: 100%;
}

.flex.items-center.justify-between.px-3.py-2.rounded-md.cursor-pointer p {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}

/* Fixed header styling */
.fixed-header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 20;
  height: 50px;
  background-color: #ffffff;
  border-bottom: 1px solid #e2e8f0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dark .fixed-header {
  background-color: #1e293b;
  border-bottom: 1px solid #334155;
}

.fixed-header h1 {
  letter-spacing: 0.5px;
}

/* Adjust containers for fixed header */
.chat-container {
  padding-top: 50px; /* Match fixed-header height */
}

.chat-main {
  padding-top: 0;
}

.sidebar-container {
  margin-top: 0;
}

/* Fix for delete button */
.sidebar-chat-item .delete-btn {
  display: flex;
  opacity: 0.8;
  transition: all 0.2s ease;
}

.sidebar-chat-item:hover .delete-btn {
  opacity: 1;
}

/* ... other existing styles ... */

/* Sidebar trashcan icon styling */
.sidebar-chat-item svg {
  visibility: visible !important;
  opacity: 0.7;
  transition: all 0.2s ease-in-out;
}

.sidebar-chat-item:hover svg {
  opacity: 1;
  color: #ef4444;
}

/* Fix for delete button on multiple platforms */
.sidebar-chat-item svg {
  display: inline-block;
  min-width: 20px;
}

/* Clear out any padding/margin in the chat header when no messages */
.chat-messages {
  margin-top: 0;
}

/* ... other existing styles ... */

/* Trash icon styling */
.trash-icon {
  color: #9ca3af !important; /* Immer grau bis zum Hover */
  cursor: pointer;
  display: flex !important;
  visibility: hidden; /* Hide by default */
  opacity: 0; /* Fully transparent by default */
  transition: all 0.2s ease-in-out;
}

.sidebar-chat-item:hover .trash-icon {
  visibility: visible; /* Show on sidebar item hover */
  opacity: 1;
}

.trash-icon:hover {
  color: #ef4444 !important; /* Rot beim Hover */
}

/* Styles für die SVG-Elemente innerhalb der trash-icon */
.sidebar-chat-item .trash-icon svg {
  display: block !important;
  visibility: inherit; /* Inherit from parent */
  fill: currentColor !important; /* Wichtig, damit SVG die Farbe annimmt */
  color: inherit !important; /* Farbe vom Elternelement übernehmen */
}

/* Extra Selektoren, um die hover Farbe zu überschreiben */
.sidebar-chat-item:hover .trash-icon:hover svg {
  fill: #ef4444 !important;
  color: #ef4444 !important;
}

/* Stärkere Spezifität für den Hover-Zustand */
.trash-icon:hover svg path {
  fill: #ef4444 !important;
}

/* Pointer-Events für die Sidebar-Chat-Items */
.sidebar-chat-item {
  cursor: pointer;
}

.sidebar-chat-item p {
  cursor: pointer;
  max-width: calc(100% - 30px) !important;
}

/* ... other existing styles ... */

/* Chat bubbles styling */
.prose {
  line-height: 1.6;
  font-size: 16px !important;
}

.chat-messages {
  padding: 1.5rem 0.75rem;
}

.chat-main {
  background-color: rgb(249, 250, 251);
}

.dark .chat-main {
  background-color: rgb(17, 24, 39);
}

.chat-input {
  padding: 1rem 1.5rem;
}
</style> 